//#include<stdio.h>
//#include<string.h>
//#include<stdbool.h>
//
//int length;
//////
////////好久没写博客了，因为写那个博客，感觉自己过的其实不是很如意，写博客自己像是小丑。
////////但是自己其实是很喜欢写一些笔记的，反正也没有什么秘密，写一些注释算了。
////////这个题，我真有点模拟不出来，太菜了。
////////下面是网上找的题解代码，然后再下面是自己开始写的时候的代码，反正就是写不出来，程序不像人脑这么直观
////////像极了写数学题，不够得心应手
//////
////////模拟真难写，先看一下思路，还有别人的代码。
////////听一听音乐，不然写算法题太难受了，网易云每日推荐音乐
//////
////////看了一下思路，大概就是从交换的两个气球开始往左边和右边开始，算是一个双指针？然后再考虑一下两个气球相等的情况
////////感觉还是比较复杂的。我刚开始写的时候，那个，下标是从0还是从1开始的比较疑惑。后面发现，按照样例的意思，应该是从
////////1开始计数的。所以，假设我从 0 开始计数，就要把输入的数字减掉 1 .当然这是代码细节，但是这个题，模拟不出来呀。。
////////我看一下别人的代码，先交上去看看能不能过掉。题解还是牛，确实能过。
//////
////////假设你刚好看我的代码，看我这一大堆心路历程是个啥想法呢？哈哈哈
//////
////////#include <stdio.h>
////////#include <string.h>
////////
////////int T,n,ai,len;
////////T 表示的是样例的数目,n 表示的是操作的数目，ai 就是需要操作的那个气球，len 表示的啥？
//////
////////char balls[35];
////////表示的是气球。存输入的字母。
////////int left1,right1,left2,right2;
////////四个指针，啊，确实复杂。
////////哦哦，应该是要交换两个气球，所以要用四个指针。应该是这个意思。
//////
////////下面这个应该就是判断，左边的吧
////////void examleft(char C,int r)
////////{
////////	left1 = right1 = r; 
////////这里的 r 表示的应该就是那个 ai ，也就是输入的那个气球那个位置。
////////	if (balls[r+1] == C)    right1 = r+1;   // 如果交换的两个小球是一样的,那要从它后面算起
////////这个循环是在干啥啊，没看明白，只要当前元素左边的元素和当前元素不一样，就跳出循环，起到一个什么目的呢
////////能存一下有多少个相同的元素，相同的元素超过三个就可以把这一连串元素删掉。嗷嗷。
////////	for ( ; left1 >= 0; left1 --)   
////////		if (balls[left1] != C)
////////			break;
////////下面这行真的好细节啊，我每次写这种都是输出看一下到底是个啥情况，每次都拿不准到底这个指针的数字是啥
////////嗷嗷，现在完全懂了，是的，因为我们平常不需要存这个指针，指针不满足循环条件，退出循环就好了。
////////	left1 ++;      // 因为for循环是最后执行 left--的,所以left都停留在“下一位”,这里给它回退一位
////////}
////////
//////
////////害，其实还是不是很懂，这里的指针表达的情况，还是得自己写代码和自己的逻辑去自洽。
////////大概的意思就是从当前元素开始算，算到最后一个元素呗。那被选中的两个元素是个啥情况。
////////暂时先把那两个元素看成一个元素吧。
////////void examright(char C,int l)
////////{
////////	left2 = right2 = l;
////////	if (balls[l-1] == C)    left2 = l-1;    // 从前面一位开始
////////	for ( ; right2 < len; right2 ++)
////////		if (balls[right2] != C)
////////			break;
////////	right2 --;    // 同上
////////}
////////
//////
//////
////////这个英文单词是啥意思，查了一下，结合这个题，消除的意思。
////////void wipe()
////////{//
////////这个计数器应该就是看有没有 3 个相同的字符
////////	int cnt = 0;
////////临时数组存元素，题解里面说存消除之后剩下的气球。
////////	char newball[35] = {0};
////////这个东西，每次写这种题都是，比如说 1 2 3 ，三个数字，3-1+1 才表示的是这里面有多少个数字
////////right1-left1+1 才表示的是这个气球的个数 所以下面的代码等价于 right1-left1+1>=3
////////	if (right1-left1 >= 2)      // 相差>=2,说明中间隔了三个及以上的相同小球,可消去
////////		for (int i = left1; i <= right1; i ++)
////////			balls[i] = ' ';
////////上面是改成空字符存下来，我最开始是准备用布尔数组标记，还是不熟练，只能说。
////////就相当于左边的左边，右边的右边都消除完了。
////////	if (right2-left2 >= 2)
////////		for (int i = left2; i <= right2; i ++)
////////			balls[i] = ' ';
////////	
////////把剩下的气球存进新的数组，这种写法感觉比较常见
////////	for (int i = 0; i < len; i ++)
////////		if (balls[i] != ' ')
////////			newball[cnt++] = balls[i];
//////
////////这个字符串复制的函数，我一直知道，但是很少用，平时是用数组循环那种，还是用一下封装好的函数比较好。
////////	strcpy(balls,newball);
////////	if (balls[0] == '\0')   puts("Over");
////////	else    printf("%s\n",balls);
////////}
////////
////////int main()
////////{
////////	scanf("%d",&T);
////////	while ( T --)
////////	{
////////		scanf("%s",balls);
////////		scanf("%d",&n);
////////		for (int i = 0; i < n; i ++)
////////		{
////////			len = strlen(balls);
////////题解作者牛，一下子就注意到这一点。
////////			scanf("%d",&ai);    ai --;       // 题目默认是从1开始数,我们是从0下标开始输入的,所以-1
////////这样子就直接可以嘛，我是还写了一个函数，引用地址啥的搞一大堆。
////////			char c = balls[ai];              // 交换
////////			balls[ai] = balls[ai+1], balls[ai+1] = c;
////////到这里才搞清楚，原来这个函数是这么用的，就是把左边的元素，算它的左边的元素
////////算右边的元素，和它右边的所有的元素，感觉有点递归的感觉，再看一下消除函数咋写的。
////////			examleft(balls[ai],ai);          // 查找是否可消除小球
////////			examright(balls[ai+1],ai+1);
//////
////////这里全部看下来，感觉也不是很难，但是这个是怎么操作好的呢？感觉，有点没太理解到这个意思。
////////主要就是，假设两个元素是相等的，那么，那怎么样呢？	嗷嗷，是的，假设两个元素相等，就从另一个元素开始计算
////////			wipe();
////////		}
////////		puts("");
////////	}
////////	return 0;
////////}
//////
////////存刚开始输入的元素
//char ball[40];
//////临时数组
//char temp[40];
//////看这个长度是不是大于等于 3 
//int len;
//////
////////试一下能不能像我这样操作。
////////void swap(char *a,char *b){
////////	char temp;
////////	temp=*a;
////////	*a=*b;
////////	*b=temp;
////////}
//////
////////我傻了。像题解一样，写，一个临时数组比较方便
////////因为要更新，所以这个函数没啥必要，用临时数组辅助，一行就能判断
////////bool is_over(){
////////	for(int i=0;i<len;i++){
////////		if(c[i]==c[i+1]&&i+1!=len){
////////			return false;
////////		}
////////	}
////////}
//////
////////确实这样子命名可以，也只能想到这样命名，能按照题解写出来也不错了，抱抱自己。
//int left1,right1,left2,right2;
//void deal_left(char C,int x){
//	if(C==ball[x+1]){
//		x++;
//	}
//	//不需要考虑越界的问题，因为越界的那个是空，不会相等的
//	
//	left1=x;
//	right1=x;
//	for(;left1>=0;left1--){
//		if(ball[left1]!=C){
//			break;
//		}
//	}
//	left1++;
//	
//	//哈哈，写出来完全一样了。没事没事。
//	
//	len=right1-left1+1;
//	if(len>=3){
//		for(int i=left1;i<=right1;i++){
//			ball[i]=' ';
//		}
//	}
//}
////
//void deal_right(char C,int x){
//	left2=x;
//	right2=x;
//	if(ball[x-1]==C){
//		x--;
//	}
//	
//	int num=strlen(ball);
//	for(;right2<num;right2++){
//		if(ball[right2]!=C){
//			break;
//		}
//	}
//	
//	right2--;
//	
//	len=right2-left2+1;
//	if(len>=3){
//		for(int i=left2;i<=right2;i++){
//			ball[i]=' ';
//		}
//	}
//}
//
////真崩溃了，不知道是哪里出问题了。
//void merge(){
//	for(int i=0;i<40;i++){
//		temp[i]='\0';
//	}
//	int cnt=0;
//	for(int i=0;i<length;i++){
//		if(ball[i]!=' '){//哦哦，应该是这里的问题，我想了一下，可以弄一个，很多注释的版本，再搞一个纯代码纯享版本
//			//这个是从 0 开始存的，假设是 ++cnt 就是从 1 这个下标开始存的
//			temp[cnt++]=ball[i];
//		}//但是临时数组是从0开始存的，没啥问题吧，哦哦，先把临时数组清空吧。
//	}
////	
//	//临时数组写在后面
//	strcpy(ball,temp);
//}
//////
//int main(){
//	int t;
//	scanf("%d",&t);
//	while(t--){
//		scanf("%s",ball);
//		length=strlen(ball);
//		//之前本来是想看，这个数组的长度啥的，就是这块使不上劲，感觉就是一些经验积累吧，或者别人说的码力。
////		len=strlen(c);
////		printf("%d\n",len);
//		
//		//之前写是想在这里测试一下
////		swap(&c[0],&c[1]);
////		for(int i=0;i<len;i++){
////			printf("%c",c[i]);
////		}
////		puts("");
//		
//		
//		int n;
//		scanf("%d",&n);
//		
//		while(n--){
//			int x;
//			scanf("%d",&x);
//			//自己第一次写的时候注意到了这一点，夸夸自己，但是，没写出来，还是有点无奈。
//			x--;
//			//奥，之前好像测试了一下，这个自定义的 swap 函数能用
////			swap(&ball[x],&ball[x+1]);
//			char temp_c=ball[x];
//			ball[x]=ball[x+1];
//			ball[x+1]=temp_c;
//			deal_left(ball[x],x);
//			//卧槽，不是交换函数的原因。估计是 merge 这个函数的问题。
//			deal_right(ball[x+1],x+1);
//			merge();
//			
//			if(ball[0]=='\0'){
//				printf("Over\n");
//			}else{
//				printf("%s",ball);
//			}
//			puts("");
//			
//			//不能过样例，我傻掉了，难道是没把数组清空的原因嘛？
//			
//			//不需要用布尔标记了，感觉自己能敲出来和题解一样的代码也差不多了。没事，跟着题解学会也行
//			//这不丢人，学会了就是好的。就像以前自己高中刷练习册一样，谁都会有不会写的题，学会了，就好
////			bool flag=false;
////			for(int i=0;i<len;){
////				int cnt=0;
////				while(c[i]==c[i+1]){
////					i++;
////					cnt++;
////				}
////				if(cnt<3){
////					flag=false;
////					break;
////				}
////				
////				if(c[i]!=c[i+1]){
////					
////				}
////			}
////			
////			if(flag==false){
////				for(int i=0;i<len;i++){
////					printf("%c",c[i]);
////				}
////				puts("");
////			}
//		}
//		//不是这里的问题，应该是交换的那里的原因，相同的元素没有消除，我傻掉了。
////		for(int i=0;i<40;i++){
////			ball[i]='\0';
////			temp[i]='\0';
////		}
//	}
//	
//	return 0;
//}
////
//
//上面的代码怎么也改不对，哭了。
//好像问题就是，应该要在更新 x 之后再更新 left1 left2 right1 right2
//哈哈哈，自己相当于对着题解抄了一遍，无所谓，明白了就行，上面像是自己写题的草稿纸。


#include<stdio.h>
#include<string.h>
#define N 40

char balls[N];
char temp[N];

int left1,right1,left2,right2;
int len;
void left(char c,int x){
	if(balls[x+1]==c){
		x++;
	}
	left1=x;
	right1=x;
	
	for(;left1>=0;left1--){
		if(balls[left1]!=c){
			break;
		}
	}
	
	left1++;
}
void right(char c,int x){
	if(balls[x-1]==c){
		x--;
	}
	left2=x;
	right2=x;
	for(;right2<len;right2++){
		if(balls[right2]!=c){
			break;
		}
	}
	right2--;
}
void deal(){
	int cnt=0;
	for(int i=0;i<N;i++){
		temp[i]='\0';
	}
	if(right1-left1+1>=3){
		for(int i=left1;i<=right1;i++){
			balls[i]=' ';
		}
	}
	if(right2-left2+1>=3){
		for(int i=left2;i<=right2;i++){
			balls[i]=' ';
		}
	}
	for(int i=0;i<len;i++){
		if(balls[i]!=' '){
			temp[cnt++]=balls[i];
		}
	}
	strcpy(balls,temp);
	if(balls[0]=='\0'){
		printf("Over\n");
	}else{
		printf("%s\n",balls);
	}
}

int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		scanf("%s",balls);
		int n;
		scanf("%d",&n);
		while(n--){
			int x;
			scanf("%d",&x);
			x--;
			len=strlen(balls);
			char c=balls[x];
			balls[x]=balls[x+1];
			balls[x+1]=c;
			left(balls[x],x);
			right(balls[x+1],x+1);
			deal();
		}
		puts("");
	}
	
	return 0;
}
